{"version":3,"sources":["../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/base.js","../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/line.vert.js","../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/line.js","../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/line.frag.js","../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/markers.vert.js","../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/markers.js","../node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/markers.frag.js","../node_modules/gloo2/gloo2.js"],"names":["BaseGLGlyph","gl","glyph","this","nvertices","size_changed","data_changed","visuals_changed","init","n","_ctx","indices","mainglyph","wx","wy","renderer","map_to_screen","dx","dy","isNaN","logger","warn","model","type","Math","min","max","abs","sx","sy","plot_view","canvas_view","webgl","canvas","width","height","trans","pixel_ratio","draw","visual_prop_is_singular","visual","propname","undefined","spec","value","attach_color","prog","vbo","att_name","prefix","rgba","colorname","alphaname","doit","used","color2rgba","set_attribute","alphas","colors","result","i","end","push","cache","val","a","Float32Array","fill_array_with_float","j","set_size","set_data","__name__","DashAtlas","_atlas","_index","_width","_height","tex","Texture2D","set_wrapping","REPEAT","set_interpolation","NEAREST","RGBA","Uint8Array","get_atlas_data","pattern","key","join","make_pattern","data","period","map","x","length","concat","C","c","b","Z","dash_end","dash_start","dash_type","index","val_at_index","endj","joins","miter","round","bevel","caps","none","o","square","butt","LineGLGlyph","_scale_aspect","Program","set_shaders","index_buffer","IndexBuffer","vbo_position","VertexBuffer","vbo_tangents","vbo_segment","vbo_angles","vbo_texcoord","dash_atlas","mainGlyph","mainGlGlyph","glglyph","isFinite","_baked_offset","_set_data","_set_visuals","scale_length","sqrt","_update_scale","set_uniform","cumsum","set_texture","baked_offset","I_triangles","Uint16Array","TRIANGLES","Array","from","chunks","ceil","uint16_index","floor","chunk","these_indices","offset","_bake","V_position","V_tangents","V_angles","V_texcoord","color","visuals","line","line_color","line_alpha","cap","line_cap","line_join","line_width","dash_pattern","line_dash","dash_index","dash_period","line_dash_offset","I","T","V_angles2","V_position2","V_tangents2","V_texcoord2","Vp","Vt","_x","Float64Array","_y","tangents","A","atan2","m","k","ni","Uint32Array","V_segment2","N","V_segment","pow","MarkerGLGlyph","marker_code","frag","_marker_code","vbo_x","vbo_y","vbo_s","vbo_a","vbo_linewidth","vbo_fg_color","vbo_bg_color","CircleView","_radius","last_trans","sradius","s","POINTS","ua","window","navigator","userAgent","indexOf","xx","yy","_angle","_size","name","attach_float","fill","mk_marker","code","CircleGLGlyph","SquareGLGlyph","DiamondGLGlyph","TriangleGLGlyph","InvertedTriangleGLGlyph","HexGLGlyph","CrossGLGlyph","CircleCrossGLGlyph","SquareCrossGLGlyph","DiamondCrossGLGlyph","XGLGlyph","CircleXGLGlyph","SquareXGLGlyph","AsteriskGLGlyph","Buffer","GlooObject","Texture3DLike","check_error","console","_pyfunc_add","isArray","_pyfunc_contains","_pyfunc_equals","constructor","Object","String","e","Error","equals","iseq","akeys","keys","bkeys","sort","_pyfunc_instantiate","ob","args","global","nobind","bind","__init__","apply","_pyfunc_mult","_pymeth_repeat","call","t","res","_pyfunc_truthy","v","byteLength","getOwnPropertyNames","_pymeth_append","append","arguments","_pymeth_get","d","get","_pymeth_keys","_pymeth_lstrip","chars","lstrip","slice","_pymeth_remove","remove","splice","count","repeat","valueOf","_pymeth_startswith","startswith","when","err","err_3","errors","msg","stub1_seq","stub2_itr","getError","NO_ERROR","prototype","_base_class","_class_name","_gl","handle","_create","err_2","create","UTYPEMAP","ATYPEMAP","ATYPEINFO","createProgram","locations","_unset_variables","_validated","_samplers","_attributes","_known_invalid","delete","deleteProgram","activate","useProgram","deactivate","vert","err_4","frag_handle","status","stub3_","tmp","type_","vert_handle","_linked","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","_get_active_attributes_and_uniforms","detachShader","deleteShader","attributes","ca","container","cu","getActive","getLocation","info","regex","stub4_","stub5_seq","stub6_itr","uniforms","RegExp","ACTIVE_UNIFORMS","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","getActiveUniform","getUniformLocation","match","size","iter0","i0","unit","log","_target","uniform1i","a_type","funcname","name_","stride","is_vbo","stub7_","FALSE","_pre_draw","attr_handle","stub10_","stub11_seq","stub8_","stub9_seq","tex_handle","tex_target","vbo_handle","hasOwnProperty","activeTexture","TEXTURE0","bindTexture","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","disableVertexAttribArray","_validate","validateProgram","VALIDATE_STATUS","mode","selection","first","gtype","stub12_","_buffer_size","UNSIGNED_SHORT","drawElements","drawArrays","_usage","createBuffer","deleteBuffer","nbytes","bufferData","bufferSubData","_types","createTexture","_shape_format","deleteTexture","_get_alignment","alignment","stub13_seq","stub14_itr","wrap_s","wrap_t","texParameterf","TEXTURE_WRAP_S","TEXTURE_WRAP_T","mag","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","shape","format","stub15_","texImage2D","UNSIGNED_BYTE","u_shape","stub16_","stub17_","y","pixelStorei","UNPACK_ALIGNMENT","texSubImage2D","GLSL_SAMPLE_NEAREST","GLSL_SAMPLE_LINEAR","_get_tile_info","max_size","ncols","nrows","getParameter","MAX_TEXTURE_SIZE","sim_shape","stub18_","u_tiles","col","elements_per_tile","row","stub19_","stub20_","tile","z","zeros","_pyfunc_all","Type","module","exports"],"mappings":"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","file":"static/js/3.0bfdbef4.chunk.js","sourcesContent":["import { color2rgba } from \"../../../core/util/color\";\nimport { logger } from \"../../../core/logging\";\nexport class BaseGLGlyph {\n    constructor(gl, glyph) {\n        this.gl = gl;\n        this.glyph = glyph;\n        this.nvertices = 0;\n        this.size_changed = false;\n        this.data_changed = false;\n        this.visuals_changed = false;\n        this.init();\n    }\n    set_data_changed(n) {\n        if (n != this.nvertices) {\n            this.nvertices = n;\n            this.size_changed = true;\n        }\n        this.data_changed = true;\n    }\n    set_visuals_changed() {\n        this.visuals_changed = true;\n    }\n    render(_ctx, indices, mainglyph) {\n        // Get transform\n        const [a, b, c] = [0, 1, 2];\n        let wx = 1; // Weights to scale our vectors\n        let wy = 1;\n        let [dx, dy] = this.glyph.renderer.map_to_screen([a * wx, b * wx, c * wx], [a * wy, b * wy, c * wy]);\n        if (isNaN(dx[0] + dx[1] + dx[2] + dy[0] + dy[1] + dy[2])) {\n            logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`);\n            return false;\n        }\n        // Try again, but with weighs so we're looking at ~100 in screen coordinates\n        wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1e12);\n        wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1e12);\n        [dx, dy] = this.glyph.renderer.map_to_screen([a * wx, b * wx, c * wx], [a * wy, b * wy, c * wy]);\n        // Test how linear it is\n        if ((Math.abs((dx[1] - dx[0]) - (dx[2] - dx[1])) > 1e-6) ||\n            (Math.abs((dy[1] - dy[0]) - (dy[2] - dy[1])) > 1e-6)) {\n            logger.warn(`WebGL backend (${this.glyph.model.type}): falling back to canvas rendering`);\n            return false;\n        }\n        const [sx, sy] = [(dx[1] - dx[0]) / wx, (dy[1] - dy[0]) / wy];\n        const { width, height } = this.glyph.renderer.plot_view.canvas_view.webgl.canvas;\n        const trans = {\n            pixel_ratio: this.glyph.renderer.plot_view.canvas.pixel_ratio,\n            width, height,\n            dx: dx[0] / sx, dy: dy[0] / sy, sx, sy,\n        };\n        this.draw(indices, mainglyph, trans);\n        return true;\n    }\n}\nBaseGLGlyph.__name__ = \"BaseGLGlyph\";\nexport function line_width(width) {\n    // Increase small values to make it more similar to canvas\n    if (width < 2) {\n        width = Math.sqrt(width * 2);\n    }\n    return width;\n}\nexport function fill_array_with_float(n, val) {\n    const a = new Float32Array(n);\n    for (let i = 0, end = n; i < end; i++) {\n        a[i] = val;\n    }\n    return a;\n}\nexport function fill_array_with_vec(n, m, val) {\n    const a = new Float32Array(n * m);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            a[i * m + j] = val[j];\n        }\n    }\n    return a;\n}\nexport function visual_prop_is_singular(visual, propname) {\n    // This touches the internals of the visual, so we limit use in this function\n    // See renderer.ts:cache_select() for similar code\n    return visual[propname].spec.value !== undefined;\n}\nexport function attach_float(prog, vbo, att_name, n, visual, name) {\n    // Attach a float attribute to the program. Use singleton value if we can,\n    // otherwise use VBO to apply array.\n    if (!visual.doit) {\n        vbo.used = false;\n        prog.set_attribute(att_name, 'float', [0]);\n    }\n    else if (visual_prop_is_singular(visual, name)) {\n        vbo.used = false;\n        prog.set_attribute(att_name, 'float', visual[name].value());\n    }\n    else {\n        vbo.used = true;\n        const a = new Float32Array(visual.cache[name + '_array']);\n        vbo.set_size(n * 4);\n        vbo.set_data(0, a);\n        prog.set_attribute(att_name, 'float', vbo);\n    }\n}\nexport function attach_color(prog, vbo, att_name, n, visual, prefix) {\n    // Attach the color attribute to the program. If there's just one color,\n    // then use this single color for all vertices (no VBO). Otherwise we\n    // create an array and upload that to the VBO, which we attahce to the prog.\n    let rgba;\n    const m = 4;\n    const colorname = prefix + '_color';\n    const alphaname = prefix + '_alpha';\n    if (!visual.doit) {\n        // Don't draw (draw transparent)\n        vbo.used = false;\n        prog.set_attribute(att_name, 'vec4', [0, 0, 0, 0]);\n    }\n    else if (visual_prop_is_singular(visual, colorname) && visual_prop_is_singular(visual, alphaname)) {\n        // Nice and simple; both color and alpha are singular\n        vbo.used = false;\n        rgba = color2rgba(visual[colorname].value(), visual[alphaname].value());\n        prog.set_attribute(att_name, 'vec4', rgba);\n    }\n    else {\n        // Use vbo; we need an array for both the color and the alpha\n        let alphas, colors;\n        vbo.used = true;\n        // Get array of colors\n        if (visual_prop_is_singular(visual, colorname)) {\n            colors = ((() => {\n                const result = [];\n                for (let i = 0, end = n; i < end; i++) {\n                    result.push(visual[colorname].value());\n                }\n                return result;\n            })());\n        }\n        else {\n            colors = visual.cache[colorname + '_array'];\n        }\n        // Get array of alphas\n        if (visual_prop_is_singular(visual, alphaname)) {\n            alphas = fill_array_with_float(n, visual[alphaname].value());\n        }\n        else {\n            alphas = visual.cache[alphaname + '_array'];\n        }\n        // Create array of rgbs\n        const a = new Float32Array(n * m);\n        for (let i = 0, end = n; i < end; i++) {\n            rgba = color2rgba(colors[i], alphas[i]);\n            for (let j = 0, endj = m; j < endj; j++) {\n                a[(i * m) + j] = rgba[j];\n            }\n        }\n        // Attach vbo\n        vbo.set_size(n * m * 4);\n        vbo.set_data(0, a);\n        prog.set_attribute(att_name, 'vec4', vbo);\n    }\n}\n//# sourceMappingURL=base.js.map","export const vertex_shader = `\nprecision mediump float;\n\nconst float PI = 3.14159265358979323846264;\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\n\nuniform float u_pixel_ratio;\nuniform vec2 u_canvas_size, u_offset;\nuniform vec2 u_scale_aspect;\nuniform float u_scale_length;\n\nuniform vec4 u_color;\nuniform float u_antialias;\nuniform float u_length;\nuniform float u_linewidth;\nuniform float u_dash_index;\nuniform float u_closed;\n\nattribute vec2 a_position;\nattribute vec4 a_tangents;\nattribute vec2 a_segment;\nattribute vec2 a_angles;\nattribute vec2 a_texcoord;\n\nvarying vec4  v_color;\nvarying vec2  v_segment;\nvarying vec2  v_angles;\nvarying vec2  v_texcoord;\nvarying vec2  v_miter;\nvarying float v_length;\nvarying float v_linewidth;\n\nfloat cross(in vec2 v1, in vec2 v2)\n{\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\n{\n    return cross(v2-v1,v1-v3) / length(v2-v1);\n}\n\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    result = vec2( c*v.x - s*v.y,\n                   s*v.x + c*v.y );\n}\n\nvoid main()\n{\n    bool closed = (u_closed > 0.0);\n\n    // Attributes and uniforms to varyings\n    v_color = u_color;\n    v_linewidth = u_linewidth;\n    v_segment = a_segment * u_scale_length;\n    v_length = u_length * u_scale_length;\n\n    // Scale to map to pixel coordinates. The original algorithm from the paper\n    // assumed isotropic scale. We obviously do not have this.\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\n\n    // Correct angles for aspect ratio\n    vec2 av;\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\n    v_angles.x = atan(av.y, av.x);\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\n    v_angles.y = atan(av.y, av.x);\n\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\n    // and a modified alpha\n    v_color.a = min(v_linewidth, v_color.a);\n    v_linewidth = max(v_linewidth, 1.0);\n\n    // If color is fully transparent we just will discard the fragment anyway\n    if( v_color.a <= 0.0 ) {\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n\n    // This is the actual half width of the line\n    float w = ceil(u_antialias+v_linewidth)/2.0;\n\n    vec2 position = (a_position + u_offset) * abs_scale;\n\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\n    float u = a_texcoord.x;\n    float v = a_texcoord.y;\n    vec2 o1 = vec2( +t1.y, -t1.x);\n    vec2 o2 = vec2( +t2.y, -t2.x);\n\n    // This is a join\n    // ----------------------------------------------------------------\n    if( t1 != t2 ) {\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\n        vec2 t  = normalize(t1+t2);\n        vec2 o  = vec2( + t.y, - t.x);\n\n        if ( u_dash_index > 0.0 )\n        {\n            // Broken angle\n            // ----------------------------------------------------------------\n            if( (abs(angle) > THETA) ) {\n                position += v * w * o / cos(angle/2.0);\n                float s = sign(angle);\n                if( angle < 0.0 ) {\n                    if( u == +1.0 ) {\n                        u = v_segment.y + v * w * tan(angle/2.0);\n                        if( v == 1.0 ) {\n                            position -= 2.0 * w * t1 / sin(angle);\n                            u -= 2.0 * w / sin(angle);\n                        }\n                    } else {\n                        u = v_segment.x - v * w * tan(angle/2.0);\n                        if( v == 1.0 ) {\n                            position += 2.0 * w * t2 / sin(angle);\n                            u += 2.0*w / sin(angle);\n                        }\n                    }\n                } else {\n                    if( u == +1.0 ) {\n                        u = v_segment.y + v * w * tan(angle/2.0);\n                        if( v == -1.0 ) {\n                            position += 2.0 * w * t1 / sin(angle);\n                            u += 2.0 * w / sin(angle);\n                        }\n                    } else {\n                        u = v_segment.x - v * w * tan(angle/2.0);\n                        if( v == -1.0 ) {\n                            position -= 2.0 * w * t2 / sin(angle);\n                            u -= 2.0*w / sin(angle);\n                        }\n                    }\n                }\n                // Continuous angle\n                // ------------------------------------------------------------\n            } else {\n                position += v * w * o / cos(angle/2.0);\n                if( u == +1.0 ) u = v_segment.y;\n                else            u = v_segment.x;\n            }\n        }\n\n        // Solid line\n        // --------------------------------------------------------------------\n        else\n        {\n            position.xy += v * w * o / cos(angle/2.0);\n            if( angle < 0.0 ) {\n                if( u == +1.0 ) {\n                    u = v_segment.y + v * w * tan(angle/2.0);\n                } else {\n                    u = v_segment.x - v * w * tan(angle/2.0);\n                }\n            } else {\n                if( u == +1.0 ) {\n                    u = v_segment.y + v * w * tan(angle/2.0);\n                } else {\n                    u = v_segment.x - v * w * tan(angle/2.0);\n                }\n            }\n        }\n\n    // This is a line start or end (t1 == t2)\n    // ------------------------------------------------------------------------\n    } else {\n        position += v * w * o1;\n        if( u == -1.0 ) {\n            u = v_segment.x - w;\n            position -= w * t1;\n        } else {\n            u = v_segment.y + w;\n            position += w * t2;\n        }\n    }\n\n    // Miter distance\n    // ------------------------------------------------------------------------\n    vec2 t;\n    vec2 curr = a_position * abs_scale;\n    if( a_texcoord.x < 0.0 ) {\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\n\n        rotate( t1, +v_angles.x/2.0, t);\n        v_miter.x = signed_distance(curr, curr+t, position);\n\n        rotate( t2, +v_angles.y/2.0, t);\n        v_miter.y = signed_distance(next, next+t, position);\n    } else {\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\n\n        rotate( t1, -v_angles.x/2.0,t);\n        v_miter.x = signed_distance(prev, prev+t, position);\n\n        rotate( t2, -v_angles.y/2.0,t);\n        v_miter.y = signed_distance(curr, curr+t, position);\n    }\n\n    if (!closed && v_segment.x <= 0.0) {\n        v_miter.x = 1e10;\n    }\n    if (!closed && v_segment.y >= v_length)\n    {\n        v_miter.y = 1e10;\n    }\n\n    v_texcoord = vec2( u, v*w );\n\n    // Calculate position in device coordinates. Note that we\n    // already scaled with abs scale above.\n    vec2 normpos = position * sign(u_scale_aspect);\n    normpos += 0.5;  // make up for Bokeh's offset\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\n    gl_Position.y *= -1.0;\n}\n`;\n//# sourceMappingURL=line.vert.js.map","import { Program, VertexBuffer, IndexBuffer, Texture2D } from \"gloo2\";\nimport { BaseGLGlyph } from \"./base\";\nimport { vertex_shader } from \"./line.vert\";\nimport { fragment_shader } from \"./line.frag\";\nimport { color2rgba } from \"../../../core/util/color\";\nclass DashAtlas {\n    constructor(gl) {\n        this._atlas = {};\n        this._index = 0;\n        this._width = 256;\n        this._height = 256;\n        // Init texture\n        this.tex = new Texture2D(gl);\n        this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n        this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n        this.tex.set_size([this._height, this._width], gl.RGBA);\n        this.tex.set_data([0, 0], [this._height, this._width], new Uint8Array(this._height * this._width * 4));\n        // Init with solid line (index 0 is reserved for this)\n        this.get_atlas_data([1]);\n    }\n    get_atlas_data(pattern) {\n        const key = pattern.join('-');\n        const findex_period = this._atlas[key];\n        if (findex_period === undefined) {\n            const [data, period] = this.make_pattern(pattern);\n            this.tex.set_data([this._index, 0], [1, this._width], new Uint8Array(data.map((x) => x + 10)));\n            this._atlas[key] = [this._index / this._height, period];\n            this._index += 1;\n        }\n        return this._atlas[key];\n    }\n    make_pattern(pattern) {\n        // A pattern is defined as on/off sequence of segments\n        // It must be a multiple of 2\n        if (pattern.length > 1 && pattern.length % 2) {\n            pattern = pattern.concat(pattern);\n        }\n        // Period is sum of elements\n        let period = 0;\n        for (const v of pattern) {\n            period += v;\n        }\n        // Find all start and end of on-segment only\n        const C = [];\n        let c = 0;\n        for (let i = 0, end = pattern.length + 2; i < end; i += 2) {\n            const a = Math.max(0.0001, pattern[i % pattern.length]);\n            const b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n            C.push(c, c + a);\n            c += a + b;\n        }\n        // Build pattern\n        const n = this._width;\n        const Z = new Float32Array(n * 4);\n        for (let i = 0, end = n; i < end; i++) {\n            let dash_end, dash_start, dash_type;\n            const x = (period * i) / (n - 1);\n            // get index at min - index = np.argmin(abs(C-(x)))\n            let index = 0;\n            let val_at_index = 1e16;\n            for (let j = 0, endj = C.length; j < endj; j++) {\n                const val = Math.abs(C[j] - x);\n                if (val < val_at_index) {\n                    index = j;\n                    val_at_index = val;\n                }\n            }\n            if ((index % 2) === 0) {\n                dash_type = (x <= C[index]) ? +1 : 0;\n                dash_start = C[index];\n                dash_end = C[index + 1];\n            }\n            else {\n                dash_type = (x > C[index]) ? -1 : 0;\n                dash_start = C[index - 1];\n                dash_end = C[index];\n            }\n            Z[(i * 4) + 0] = C[index];\n            Z[(i * 4) + 1] = dash_type;\n            Z[(i * 4) + 2] = dash_start;\n            Z[(i * 4) + 3] = dash_end;\n        }\n        return [Z, period];\n    }\n}\nDashAtlas.__name__ = \"DashAtlas\";\nconst joins = { miter: 0, round: 1, bevel: 2 };\nconst caps = {\n    '': 0, none: 0, '.': 0,\n    round: 1, ')': 1, '(': 1, o: 1,\n    'triangle in': 2, '<': 2,\n    'triangle out': 3, '>': 3,\n    square: 4, '[': 4, ']': 4, '=': 4,\n    butt: 5, '|': 5,\n};\nexport class LineGLGlyph extends BaseGLGlyph {\n    init() {\n        const { gl } = this;\n        this._scale_aspect = 0; // keep track, so we know when we need to update segment data\n        const vert = vertex_shader;\n        const frag = fragment_shader;\n        // The program\n        this.prog = new Program(gl);\n        this.prog.set_shaders(vert, frag);\n        this.index_buffer = new IndexBuffer(gl);\n        // Buffers\n        this.vbo_position = new VertexBuffer(gl);\n        this.vbo_tangents = new VertexBuffer(gl);\n        this.vbo_segment = new VertexBuffer(gl);\n        this.vbo_angles = new VertexBuffer(gl);\n        this.vbo_texcoord = new VertexBuffer(gl);\n        // Dash atlas\n        this.dash_atlas = new DashAtlas(gl);\n    }\n    draw(indices, mainGlyph, trans) {\n        const mainGlGlyph = mainGlyph.glglyph;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return; // not sure why, but it happens on init sometimes (#4367)\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy]; // float32 precision workaround; used in _bake() and below\n            mainGlGlyph._set_data();\n            mainGlGlyph.data_changed = false;\n        }\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        // Decompose x-y scale into scalar scale and aspect-vector.\n        let { sx, sy } = trans;\n        const scale_length = Math.sqrt(sx * sx + sy * sy);\n        sx /= scale_length;\n        sy /= scale_length;\n        // Do we need to re-calculate segment data and cumsum?\n        if (Math.abs(this._scale_aspect - sy / sx) > Math.abs(1e-3 * this._scale_aspect)) {\n            mainGlGlyph._update_scale(sx, sy);\n            this._scale_aspect = sy / sx;\n        }\n        // Select buffers from main glyph\n        // (which may be this glyph but maybe not if this is a (non)selection glyph)\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n        //\n        this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n        this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n        // Handle transformation to device coordinates\n        const baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale_aspect', 'vec2', [sx, sy]);\n        this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n        this.I_triangles = mainGlGlyph.I_triangles;\n        if (this.I_triangles.length < 65535) {\n            // Data is small enough to draw in one pass\n            this.index_buffer.set_size(this.I_triangles.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n            this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n            // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\n        }\n        else {\n            // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n            // First collect indices in chunks\n            indices = Array.from(this.I_triangles);\n            const nvertices = this.I_triangles.length;\n            const chunksize = 64008; // 65536 max. 64008 is divisible by 12\n            const chunks = [];\n            for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\n                chunks.push([]);\n            }\n            for (let i = 0, end = indices.length; i < end; i++) {\n                const uint16_index = indices[i] % chunksize;\n                const chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            // Then draw each chunk\n            for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\n                const these_indices = new Uint16Array(chunks[chunk]);\n                const offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                // The actual drawing\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n            }\n        }\n    }\n    _set_data() {\n        this._bake();\n        this.vbo_position.set_size(this.V_position.length * 4);\n        this.vbo_position.set_data(0, this.V_position);\n        this.vbo_tangents.set_size(this.V_tangents.length * 4);\n        this.vbo_tangents.set_data(0, this.V_tangents);\n        this.vbo_angles.set_size(this.V_angles.length * 4);\n        this.vbo_angles.set_data(0, this.V_angles);\n        this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n        this.vbo_texcoord.set_data(0, this.V_texcoord);\n    }\n    _set_visuals() {\n        const color = color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n        const cap = caps[this.glyph.visuals.line.line_cap.value()];\n        const join = joins[this.glyph.visuals.line.line_join.value()];\n        this.prog.set_uniform('u_color', 'vec4', color);\n        this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n        this.prog.set_uniform('u_antialias', 'float', [0.9]); // Smaller aa-region to obtain crisper images\n        this.prog.set_uniform('u_linecaps', 'vec2', [cap, cap]);\n        this.prog.set_uniform('u_linejoin', 'float', [join]);\n        this.prog.set_uniform('u_miter_limit', 'float', [10.0]); // 10 should be a good value\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n        const dash_pattern = this.glyph.visuals.line.line_dash.value();\n        let dash_index = 0;\n        let dash_period = 1;\n        if (dash_pattern.length) {\n            [dash_index, dash_period] = this.dash_atlas.get_atlas_data(dash_pattern);\n        }\n        this.prog.set_uniform('u_dash_index', 'float', [dash_index]); // 0 means solid line\n        this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n        this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n        this.prog.set_uniform('u_dash_caps', 'vec2', [cap, cap]);\n        this.prog.set_uniform('u_closed', 'float', [0]); // We dont do closed lines\n    }\n    _bake() {\n        // This is what you get if you port 50 lines of numpy code to JS.\n        // V_segment is handled in another method, because it depends on the aspect\n        // ratio of the scale (The original paper/code assumed isotropic scaling).\n        //\n        // Buffer dtype from the Python implementation:\n        //\n        // self.vtype = np.dtype( [('a_position', 'f4', 2),\n        //                         ('a_segment',  'f4', 2),\n        //                         ('a_angles',   'f4', 2),\n        //                         ('a_tangents', 'f4', 4),\n        //                         ('a_texcoord', 'f4', 2) ])\n        // Init array of implicit shape nx2\n        let I, T, V_angles2, V_position2, V_tangents2, V_texcoord2, Vp, Vt;\n        const n = this.nvertices;\n        const _x = new Float64Array(this.glyph._x);\n        const _y = new Float64Array(this.glyph._y);\n        // Init vertex data\n        const V_position = (Vp = new Float32Array(n * 2));\n        //V_segment = new Float32Array(n*2)  # Done later\n        const V_angles = new Float32Array(n * 2);\n        const V_tangents = (Vt = new Float32Array(n * 4)); // mind the 4!\n        // Position\n        for (let i = 0, end = n; i < end; i++) {\n            V_position[(i * 2) + 0] = _x[i] + this._baked_offset[0];\n            V_position[(i * 2) + 1] = _y[i] + this._baked_offset[1];\n        }\n        // Tangents & norms (need tangents to calculate segments based on scale)\n        this.tangents = (T = new Float32Array((n * 2) - 2));\n        for (let i = 0, end = n - 1; i < end; i++) {\n            T[(i * 2) + 0] = Vp[((i + 1) * 2) + 0] - Vp[(i * 2) + 0];\n            T[(i * 2) + 1] = Vp[((i + 1) * 2) + 1] - Vp[(i * 2) + 1];\n        }\n        for (let i = 0, end = n - 1; i < end; i++) {\n            // V['a_tangents'][+1:, :2] = T\n            V_tangents[((i + 1) * 4) + 0] = T[(i * 2) + 0];\n            V_tangents[((i + 1) * 4) + 1] = T[(i * 2) + 1];\n            // V['a_tangents'][:-1, 2:] = T\n            V_tangents[(i * 4) + 2] = T[(i * 2) + 0];\n            V_tangents[(i * 4) + 3] = T[(i * 2) + 1];\n        }\n        // V['a_tangents'][0  , :2] = T[0]\n        V_tangents[(0 * 4) + 0] = T[0];\n        V_tangents[(0 * 4) + 1] = T[1];\n        // V['a_tangents'][ -1, 2:] = T[-1]\n        V_tangents[((n - 1) * 4) + 2] = T[((n - 2) * 2) + 0];\n        V_tangents[((n - 1) * 4) + 3] = T[((n - 2) * 2) + 1];\n        // Angles\n        const A = new Float32Array(n);\n        for (let i = 0, end = n; i < end; i++) {\n            A[i] = Math.atan2((Vt[(i * 4) + 0] * Vt[(i * 4) + 3]) - (Vt[(i * 4) + 1] * Vt[(i * 4) + 2]), (Vt[(i * 4) + 0] * Vt[(i * 4) + 2]) + (Vt[(i * 4) + 1] * Vt[(i * 4) + 3]));\n        }\n        for (let i = 0, end = n - 1; i < end; i++) {\n            V_angles[(i * 2) + 0] = A[i];\n            V_angles[(i * 2) + 1] = A[i + 1];\n        }\n        // Step 1: A -- B -- C  =>  A -- B, B' -- C\n        // Repeat our array 4 times\n        const m = (4 * n) - 4;\n        this.V_position = (V_position2 = new Float32Array(m * 2));\n        this.V_angles = (V_angles2 = new Float32Array(m * 2));\n        this.V_tangents = (V_tangents2 = new Float32Array(m * 4)); // mind the 4!\n        this.V_texcoord = (V_texcoord2 = new Float32Array(m * 2));\n        const o = 2;\n        //\n        // Arg, we really need an ndarray thing in JS :/\n        for (let i = 0, end = n; i < end; i++) { // all nodes on the line\n            for (let j = 0; j < 4; j++) { // the four quad vertices\n                for (let k = 0; k < 2; k++) { // xy\n                    V_position2[((((i * 4) + j) - o) * 2) + k] = V_position[(i * 2) + k];\n                    V_angles2[(((i * 4) + j) * 2) + k] = V_angles[(i * 2) + k];\n                } // no offset\n                for (let k = 0; k < 4; k++) {\n                    V_tangents2[((((i * 4) + j) - o) * 4) + k] = V_tangents[(i * 4) + k];\n                }\n            }\n        }\n        for (let i = 0, end = n; i < end; i++) {\n            V_texcoord2[(((i * 4) + 0) * 2) + 0] = -1;\n            V_texcoord2[(((i * 4) + 1) * 2) + 0] = -1;\n            V_texcoord2[(((i * 4) + 2) * 2) + 0] = +1;\n            V_texcoord2[(((i * 4) + 3) * 2) + 0] = +1;\n            //\n            V_texcoord2[(((i * 4) + 0) * 2) + 1] = -1;\n            V_texcoord2[(((i * 4) + 1) * 2) + 1] = +1;\n            V_texcoord2[(((i * 4) + 2) * 2) + 1] = -1;\n            V_texcoord2[(((i * 4) + 3) * 2) + 1] = +1;\n        }\n        // Indices\n        //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\n        //I += np.repeat( 4*np.arange(n-1), 6)\n        const ni = (n - 1) * 6;\n        this.I_triangles = (I = new Uint32Array(ni));\n        // Order of indices is such that drawing as line_strip reveals the line skeleton\n        // Might have implications on culling, if we ever turn that on.\n        // Order in paper was: 0 1 2 1 2 3\n        for (let i = 0, end = n; i < end; i++) {\n            I[(i * 6) + 0] = 0 + (4 * i);\n            I[(i * 6) + 1] = 1 + (4 * i);\n            I[(i * 6) + 2] = 3 + (4 * i);\n            I[(i * 6) + 3] = 2 + (4 * i);\n            I[(i * 6) + 4] = 0 + (4 * i);\n            I[(i * 6) + 5] = 3 + (4 * i);\n        }\n    }\n    _update_scale(sx, sy) {\n        // Update segment data and cumsum so the length along the line has the\n        // scale aspect ratio in it. In the vertex shader we multiply with the\n        // \"isotropic part\" of the scale.\n        let V_segment2;\n        const n = this.nvertices;\n        const m = (4 * n) - 4;\n        // Prepare arrays\n        const T = this.tangents;\n        const N = new Float32Array(n - 1);\n        const V_segment = new Float32Array(n * 2); // Elements are initialized with 0\n        this.V_segment = (V_segment2 = new Float32Array(m * 2));\n        // Calculate vector lengths - with scale aspect ratio taken into account\n        for (let i = 0, end = n - 1; i < end; i++) {\n            N[i] = Math.sqrt(Math.pow(T[(i * 2) + 0] * sx, 2) + Math.pow(T[(i * 2) + 1] * sy, 2));\n        }\n        // Calculate Segments\n        let cumsum = 0;\n        for (let i = 0, end = n - 1; i < end; i++) {\n            cumsum += N[i];\n            V_segment[((i + 1) * 2) + 0] = cumsum;\n            V_segment[(i * 2) + 1] = cumsum;\n        }\n        // Upscale (same loop as in _bake())\n        for (let i = 0, end = n; i < end; i++) {\n            for (let j = 0; j < 4; j++) {\n                for (let k = 0; k < 2; k++) {\n                    V_segment2[(((i * 4) + j) * 2) + k] = V_segment[(i * 2) + k];\n                }\n            }\n        }\n        // Update\n        this.cumsum = cumsum; // L[-1] in Nico's code\n        this.vbo_segment.set_size(this.V_segment.length * 4);\n        this.vbo_segment.set_data(0, this.V_segment);\n    }\n}\nLineGLGlyph.__name__ = \"LineGLGlyph\";\n//# sourceMappingURL=line.js.map","export const fragment_shader = `\nprecision mediump float;\n\nconst float PI = 3.14159265358979323846264;\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\n\nuniform sampler2D u_dash_atlas;\n\nuniform vec2 u_linecaps;\nuniform float u_miter_limit;\nuniform float u_linejoin;\nuniform float u_antialias;\nuniform float u_dash_phase;\nuniform float u_dash_period;\nuniform float u_dash_index;\nuniform vec2 u_dash_caps;\nuniform float u_closed;\n\nvarying vec4  v_color;\nvarying vec2  v_segment;\nvarying vec2  v_angles;\nvarying vec2  v_texcoord;\nvarying vec2  v_miter;\nvarying float v_length;\nvarying float v_linewidth;\n\n// Compute distance to cap ----------------------------------------------------\nfloat cap( int type, float dx, float dy, float t, float linewidth )\n{\n    float d = 0.0;\n    dx = abs(dx);\n    dy = abs(dy);\n    if      (type == 0)  discard;  // None\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\n    else if (type == 4)  d = max(dx,dy);  // Square\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\n    return d;\n}\n\n// Compute distance to join -------------------------------------------------\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\n           in float linewidth )\n{\n    // texcoord.x is distance from start\n    // texcoord.y is distance from centerline\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\n\n    float dx = texcoord.x;\n\n    // Round join\n    if( type == 1 ) {\n        if (dx < segment.x) {\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\n            //d = length( texcoord - vec2(segment.x,0.0));\n        } else if (dx > segment.y) {\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\n            //d = length( texcoord - vec2(segment.y,0.0));\n        }\n    }\n    // Bevel join\n    else if ( type == 2 ) {\n        if (dx < segment.x) {\n            vec2 x = texcoord - vec2(segment.x,0.0);\n            d = max(d, max(abs(x.x), abs(x.y)));\n\n        } else if (dx > segment.y) {\n            vec2 x = texcoord - vec2(segment.y,0.0);\n            d = max(d, max(abs(x.x), abs(x.y)));\n        }\n        /*  Original code for bevel which does not work for us\n        if( (dx < segment.x) ||  (dx > segment.y) )\n            d = max(d, min(abs(x.x),abs(x.y)));\n        */\n    }\n\n    return d;\n}\n\nvoid main()\n{\n    // If color is fully transparent we just discard the fragment\n    if( v_color.a <= 0.0 ) {\n        discard;\n    }\n\n    // Test if dash pattern is the solid one (0)\n    bool solid =  (u_dash_index == 0.0);\n\n    // Test if path is closed\n    bool closed = (u_closed > 0.0);\n\n    vec4 color = v_color;\n    float dx = v_texcoord.x;\n    float dy = v_texcoord.y;\n    float t = v_linewidth/2.0-u_antialias;\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\n    float d = 0.0;\n\n    vec2 linecaps = u_linecaps;\n    vec2 dash_caps = u_dash_caps;\n    float line_start = 0.0;\n    float line_stop = v_length;\n\n    // Apply miter limit; fragments too far into the miter are simply discarded\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\n          discard;\n    }\n\n    // Solid line --------------------------------------------------------------\n    if( solid ) {\n        d = abs(dy);\n        if( (!closed) && (dx < line_start) ) {\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\n        }\n        else if( (!closed) &&  (dx > line_stop) ) {\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\n        }\n        else {\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\n        }\n\n    // Dash line --------------------------------------------------------------\n    } else {\n        float segment_start = v_segment.x;\n        float segment_stop  = v_segment.y;\n        float segment_center= (segment_start+segment_stop)/2.0;\n        float freq          = u_dash_period*width;\n        float u = mod( dx + u_dash_phase*width, freq);\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n        float dash_center= tex.x * width;\n        float dash_type  = tex.y;\n        float _start = tex.z * width;\n        float _stop  = tex.a * width;\n        float dash_start = dx - u + _start;\n        float dash_stop  = dx - u + _stop;\n\n        // Compute extents of the first dash (the one relative to v_segment.x)\n        // Note: this could be computed in the vertex shader\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\n            float u = mod(segment_start + u_dash_phase*width, freq);\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n            dash_center= tex.x * width;\n            //dash_type  = tex.y;\n            float _start = tex.z * width;\n            float _stop  = tex.a * width;\n            dash_start = segment_start - u + _start;\n            dash_stop = segment_start - u + _stop;\n        }\n\n        // Compute extents of the last dash (the one relatives to v_segment.y)\n        // Note: This could be computed in the vertex shader\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\n            float u = mod(segment_stop + u_dash_phase*width, freq);\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n            dash_center= tex.x * width;\n            //dash_type  = tex.y;\n            float _start = tex.z * width;\n            float _stop  = tex.a * width;\n            dash_start = segment_stop - u + _start;\n            dash_stop  = segment_stop - u + _stop;\n        }\n\n        // This test if the we are dealing with a discontinuous angle\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\n        //if( dx < line_start) discontinuous = false;\n        //if( dx > line_stop)  discontinuous = false;\n\n        float d_join = join( int(u_linejoin), abs(dy),\n                            v_segment, v_texcoord, v_miter, v_linewidth );\n\n        // When path is closed, we do not have room for linecaps, so we make room\n        // by shortening the total length\n        if (closed) {\n             line_start += v_linewidth/2.0;\n             line_stop  -= v_linewidth/2.0;\n        }\n\n        // We also need to take antialias area into account\n        //line_start += u_antialias;\n        //line_stop  -= u_antialias;\n\n        // Check is dash stop is before line start\n        if( dash_stop <= line_start ) {\n            discard;\n        }\n        // Check is dash start is beyond line stop\n        if( dash_start >= line_stop ) {\n            discard;\n        }\n\n        // Check if current dash start is beyond segment stop\n        if( discontinuous ) {\n            // Dash start is beyond segment, we discard\n            if( (dash_start > segment_stop) ) {\n                discard;\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\n            }\n\n            // Dash stop is before segment, we discard\n            if( (dash_stop < segment_start) ) {\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\n            }\n\n            // Special case for round caps (nicer with this)\n            if( dash_caps.x == 1.0 ) {\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\n                    discard;\n                }\n            }\n\n            // Special case for round caps  (nicer with this)\n            if( dash_caps.y == 1.0 ) {\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\n                    discard;\n                }\n            }\n\n            // Special case for triangle caps (in & out) and square\n            // We make sure the cap stop at crossing frontier\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\n                    float a = v_angles.x/2.0;\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\n                    if( x > 0.0 ) discard;\n                    // We transform the cap into square to avoid holes\n                    dash_caps.x = 4.0;\n                }\n            }\n\n            // Special case for triangle caps (in & out) and square\n            // We make sure the cap stop at crossing frontier\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\n                    float a = v_angles.y/2.0;\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\n                    if( x > 0.0 ) discard;\n                    // We transform the caps into square to avoid holes\n                    dash_caps.y = 4.0;\n                }\n            }\n        }\n\n        // Line cap at start\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\n        }\n        // Line cap at stop\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\n        }\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\n        else if( dash_type < -0.5 ) {\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\n            if( (dx > line_start) && (dx < line_stop) )\n                d = max(d,d_join);\n        }\n        // Dash cap right\n        else if( dash_type > 0.5 ) {\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\n            if( (dx > line_start) && (dx < line_stop) )\n                d = max(d,d_join);\n        }\n        // Dash body (plain)\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\n            d = abs(dy);\n        }\n\n        // Line join\n        if( (dx > line_start) && (dx < line_stop)) {\n            if( (dx <= segment_start) && (dash_start <= segment_start)\n                && (dash_stop >= segment_start) ) {\n                d = d_join;\n                // Antialias at outer border\n                float angle = PI/2.+v_angles.x;\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\n                d = max(f,d);\n            }\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\n                     && (dash_stop >= segment_stop) ) {\n                d = d_join;\n                // Antialias at outer border\n                float angle = PI/2.+v_angles.y;\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\n                d = max(f,d);\n            }\n            else if( dx < (segment_start - v_linewidth/2.)) {\n                discard;\n            }\n            else if( dx > (segment_stop + v_linewidth/2.)) {\n                discard;\n            }\n        }\n        else if( dx < (segment_start - v_linewidth/2.)) {\n            discard;\n        }\n        else if( dx > (segment_stop + v_linewidth/2.)) {\n            discard;\n        }\n    }\n\n    // Distance to border ------------------------------------------------------\n    d = d - t;\n    if( d < 0.0 ) {\n        gl_FragColor = color;\n    } else {\n        d /= u_antialias;\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\n    }\n}\n`;\n//# sourceMappingURL=line.frag.js.map","export const vertex_shader = `\nprecision mediump float;\nconst float SQRT_2 = 1.4142135623730951;\n//\nuniform float u_pixel_ratio;\nuniform vec2 u_canvas_size;\nuniform vec2 u_offset;\nuniform vec2 u_scale;\nuniform float u_antialias;\n//\nattribute float a_x;\nattribute float a_y;\nattribute float a_size;\nattribute float a_angle;  // in radians\nattribute float a_linewidth;\nattribute vec4  a_fg_color;\nattribute vec4  a_bg_color;\n//\nvarying float v_linewidth;\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying vec2  v_rotation;\n\nvoid main (void)\n{\n    v_size = a_size * u_pixel_ratio;\n    v_linewidth = a_linewidth * u_pixel_ratio;\n    v_fg_color = a_fg_color;\n    v_bg_color = a_bg_color;\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\n    // Calculate position - the -0.5 is to correct for canvas origin\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\n    pos += 0.5;  // make up for Bokeh's offset\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\n    gl_Position.y *= -1.0;\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\n}\n`;\n//# sourceMappingURL=markers.vert.js.map","import { Program, VertexBuffer, IndexBuffer } from \"gloo2\";\nimport { BaseGLGlyph, attach_float, attach_color } from \"./base\";\nimport { vertex_shader } from \"./markers.vert\";\nimport { fragment_shader } from \"./markers.frag\";\nimport { CircleView } from \"../circle\";\nimport { map } from \"../../../core/util/arrayable\";\nimport { logger } from \"../../../core/logging\";\n// Base class for markers. All markers share the same GLSL, except for one\n// function that defines the marker geometry.\nexport class MarkerGLGlyph extends BaseGLGlyph {\n    init() {\n        const { gl } = this;\n        const vert = vertex_shader;\n        const frag = fragment_shader(this._marker_code);\n        // The program\n        this.prog = new Program(gl);\n        this.prog.set_shaders(vert, frag);\n        // Real attributes\n        this.vbo_x = new VertexBuffer(gl);\n        this.prog.set_attribute('a_x', 'float', this.vbo_x);\n        this.vbo_y = new VertexBuffer(gl);\n        this.prog.set_attribute('a_y', 'float', this.vbo_y);\n        this.vbo_s = new VertexBuffer(gl);\n        this.prog.set_attribute('a_size', 'float', this.vbo_s);\n        this.vbo_a = new VertexBuffer(gl);\n        this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n        // VBO's for attributes (they may not be used if value is singleton)\n        this.vbo_linewidth = new VertexBuffer(gl);\n        this.vbo_fg_color = new VertexBuffer(gl);\n        this.vbo_bg_color = new VertexBuffer(gl);\n        this.index_buffer = new IndexBuffer(gl);\n    }\n    draw(indices, mainGlyph, trans) {\n        // The main glyph has the data, *this* glyph has the visuals.\n        const mainGlGlyph = mainGlyph.glglyph;\n        const { nvertices } = mainGlGlyph;\n        // Upload data if we must. Only happens for main glyph.\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return; // not sure why, but it happens on init sometimes (#4367)\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy]; // float32 precision workaround; used in _set_data() and below\n            mainGlGlyph._set_data(nvertices);\n            mainGlGlyph.data_changed = false;\n        }\n        else if (this.glyph instanceof CircleView && this.glyph._radius != null &&\n            (this.last_trans == null || trans.sx != this.last_trans.sx || trans.sy != this.last_trans.sy)) {\n            // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\n            this.last_trans = trans;\n            this.vbo_s.set_data(0, new Float32Array(map(this.glyph.sradius, (s) => s * 2)));\n        }\n        // Update visuals if we must. Can happen for all glyphs.\n        if (this.visuals_changed) {\n            this._set_visuals(nvertices);\n            this.visuals_changed = false;\n        }\n        // Handle transformation to device coordinates\n        // Note the baked-in offset to avoid float32 precision problems\n        const baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale', 'vec2', [trans.sx, trans.sy]);\n        // Select buffers from main glyph\n        // (which may be this glyph but maybe not if this is a (non)selection glyph)\n        this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n        this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n        this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n        this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n        // Draw directly or using indices. Do not handle indices if they do not\n        // fit in a uint16; WebGL 1.0 does not support uint32.\n        if (indices.length == 0)\n            return;\n        else if (indices.length === nvertices)\n            this.prog.draw(this.gl.POINTS, [0, nvertices]);\n        else if (nvertices < 65535) {\n            // On IE the marker size is reduced to 1 px when using an index buffer\n            // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\n            // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\n            // next renderer update.\n            const ua = window.navigator.userAgent;\n            if ((ua.indexOf(\"MSIE \") + ua.indexOf(\"Trident/\") + ua.indexOf(\"Edge/\")) > 0) {\n                logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n            }\n            this.index_buffer.set_size(indices.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(indices));\n            this.prog.draw(this.gl.POINTS, this.index_buffer);\n        }\n        else {\n            // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n            // First collect indices in chunks\n            const chunksize = 64000; // 65536\n            const chunks = [];\n            for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\n                chunks.push([]);\n            }\n            for (let i = 0, end = indices.length; i < end; i++) {\n                const uint16_index = indices[i] % chunksize;\n                const chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            // Then draw each chunk\n            for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\n                const these_indices = new Uint16Array(chunks[chunk]);\n                const offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                if (this.vbo_linewidth.used) {\n                    this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                }\n                if (this.vbo_fg_color.used) {\n                    this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                }\n                if (this.vbo_bg_color.used) {\n                    this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                }\n                // The actual drawing\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                this.prog.draw(this.gl.POINTS, this.index_buffer);\n            }\n        }\n    }\n    _set_data(nvertices) {\n        const n = nvertices * 4; // in bytes\n        // Set buffer size\n        this.vbo_x.set_size(n);\n        this.vbo_y.set_size(n);\n        this.vbo_a.set_size(n);\n        this.vbo_s.set_size(n);\n        // Upload data for x and y, apply a baked-in offset for float32 precision (issue #3795)\n        // The exact value for the baked_offset does not matter, as long as it brings the data to less extreme values\n        const xx = new Float64Array(this.glyph._x);\n        const yy = new Float64Array(this.glyph._y);\n        for (let i = 0, end = nvertices; i < end; i++) {\n            xx[i] += this._baked_offset[0];\n            yy[i] += this._baked_offset[1];\n        }\n        this.vbo_x.set_data(0, new Float32Array(xx));\n        this.vbo_y.set_data(0, new Float32Array(yy));\n        // Angle if available; circle does not have angle. If we don't set data, angle is default 0 in glsl\n        if (this.glyph._angle != null) {\n            this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n        }\n        // Radius is special; some markers allow radius in data-coords instead of screen coords\n        // @radius tells us that radius is in units, sradius is the pre-calculated screen radius\n        if (this.glyph instanceof CircleView && this.glyph._radius != null)\n            this.vbo_s.set_data(0, new Float32Array(map(this.glyph.sradius, (s) => s * 2)));\n        else\n            this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n    }\n    _set_visuals(nvertices) {\n        attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n        attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n        attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n        // Static value for antialias. Smaller aa-region to obtain crisper images\n        this.prog.set_uniform('u_antialias', 'float', [0.8]);\n    }\n}\nMarkerGLGlyph.__name__ = \"MarkerGLGlyph\";\nfunction mk_marker(code) {\n    return class extends MarkerGLGlyph {\n        get _marker_code() {\n            return code;\n        }\n    };\n}\nimport * as glsl from \"./markers.frag\";\nexport const CircleGLGlyph = mk_marker(glsl.circle);\nexport const SquareGLGlyph = mk_marker(glsl.square);\nexport const DiamondGLGlyph = mk_marker(glsl.diamond);\nexport const TriangleGLGlyph = mk_marker(glsl.triangle);\nexport const InvertedTriangleGLGlyph = mk_marker(glsl.invertedtriangle);\nexport const HexGLGlyph = mk_marker(glsl.hex);\nexport const CrossGLGlyph = mk_marker(glsl.cross);\nexport const CircleCrossGLGlyph = mk_marker(glsl.circlecross);\nexport const SquareCrossGLGlyph = mk_marker(glsl.squarecross);\nexport const DiamondCrossGLGlyph = mk_marker(glsl.diamondcross);\nexport const XGLGlyph = mk_marker(glsl.x);\nexport const CircleXGLGlyph = mk_marker(glsl.circlex);\nexport const SquareXGLGlyph = mk_marker(glsl.squarex);\nexport const AsteriskGLGlyph = mk_marker(glsl.asterisk);\n//# sourceMappingURL=markers.js.map","export const fragment_shader = (marker_code) => `\nprecision mediump float;\nconst float SQRT_2 = 1.4142135623730951;\nconst float PI = 3.14159265358979323846264;\n//\nuniform float u_antialias;\n//\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying float v_linewidth;\nvarying float v_size;\nvarying vec2  v_rotation;\n\n${marker_code}\n\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\n    float select = float(bool(fg_color.a));\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\n    // Similarly, if we want a transparent bg\n    select = float(bool(bg_color.a));\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\n\n    if( border_distance < 0.0)\n        frag_color = fg_color;\n    else if( signed_distance < 0.0 ) {\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\n    } else {\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\n        } else {\n            discard;\n        }\n    }\n    return frag_color;\n}\n\nvoid main()\n{\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\n             v_rotation.y*P.x + v_rotation.x*P.y);\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\n    float distance = marker(P*point_size, v_size);\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\n}\n`;\nexport const circle = `\nfloat marker(vec2 P, float size)\n{\n    return length(P) - size/2.0;\n}\n`;\nexport const square = `\nfloat marker(vec2 P, float size)\n{\n    return max(abs(P.x), abs(P.y)) - size/2.0;\n}\n`;\nexport const diamond = `\nfloat marker(vec2 P, float size)\n{\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\n    return r1 / SQRT_2;\n}\n`;\nexport const hex = `\nfloat marker(vec2 P, float size)\n{\n    vec2 q = abs(P);\n    return max(q.y * 0.57735 + q.x - 1.0 * size/2.0, q.y - 0.866 * size/2.0);\n}\n`;\nexport const triangle = `\nfloat marker(vec2 P, float size)\n{\n    P.y -= size * 0.3;\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\n    float r2 = P.y;\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\n}\n`;\nexport const invertedtriangle = `\nfloat marker(vec2 P, float size)\n{\n    P.y += size * 0.3;\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\n    float r2 = - P.y;\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\n}\n`;\nexport const cross = `\nfloat marker(vec2 P, float size)\n{\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;   // 2.5 is a tweak\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\n    return max(square, cross);\n}\n`;\nexport const circlecross = `\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float circle = length(P) - size/2.0;\n    float c1 = max(circle, s1);\n    float c2 = max(circle, s2);\n    float c3 = max(circle, s3);\n    float c4 = max(circle, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n`;\nexport const squarecross = `\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\n    float c1 = max(square, s1);\n    float c2 = max(square, s2);\n    float c3 = max(square, s3);\n    float c4 = max(square, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n`;\nexport const diamondcross = `\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\n    diamond /= SQRT_2;\n    float c1 = max(diamond, s1);\n    float c2 = max(diamond, s2);\n    float c3 = max(diamond, s3);\n    float c4 = max(diamond, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n`;\nexport const x = `\nfloat marker(vec2 P, float size)\n{\n    float circle = length(P) - size / 1.6;\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\n    return max(circle, X);\n}\n`;\nexport const circlex = `\nfloat marker(vec2 P, float size)\n{\n    float x = P.x - P.y;\n    float y = P.x + P.y;\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float circle = length(P) - size/2.0;\n    float c1 = max(circle, s1);\n    float c2 = max(circle, s2);\n    float c3 = max(circle, s3);\n    float c4 = max(circle, s4);\n    // Union\n    float almost = min(min(min(c1, c2), c3), c4);\n    // In this case, the X is also outside of the main shape\n    float Xmask = length(P) - size / 1.6;  // a circle\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\n    return min(max(X, Xmask), almost);\n}\n`;\nexport const squarex = `\nfloat marker(vec2 P, float size)\n{\n    float x = P.x - P.y;\n    float y = P.x + P.y;\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\n    float c1 = max(square, s1);\n    float c2 = max(square, s2);\n    float c3 = max(square, s3);\n    float c4 = max(square, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n`;\nexport const asterisk = `\nfloat marker(vec2 P, float size)\n{\n    // Masks\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\n    // Shapes\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\n    // Result is union of masked shapes\n    return min(max(X, diamond), max(cross, square));\n}\n`;\n//# sourceMappingURL=markers.frag.js.map","/* Do not edit, autogenerated by flexx.pyscript */\n\nvar _pyfunc_add = function (a, b) { // nargs: 2\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.concat(b);\n    } return a + b;\n};\nvar _pyfunc_all = function (x) { // nargs: 1\n    for (var i=0; i<x.length; i++) {\n        if (!_pyfunc_truthy(x[i])){return false;}\n    } return true;\n};\nvar _pyfunc_contains = function contains (a, b) { // nargs: 2\n    if (b == null) {\n    } else if (Array.isArray(b)) {\n        for (var i=0; i<b.length; i++) {if (_pyfunc_equals(a, b[i]))\n                                           return true;}\n        return false;\n    } else if (b.constructor === Object) {\n        for (var k in b) {if (a == k) return true;}\n        return false;\n    } else if (b.constructor == String) {\n        return b.indexOf(a) >= 0;\n    } var e = Error('Not a container: ' + b); e.name='TypeError'; throw e;\n};\nvar _pyfunc_equals = function equals (a, b) { // nargs: 2\n    if (a == null || b == null) {\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        var i = 0, iseq = a.length == b.length;\n        while (iseq && i < a.length) {iseq = equals(a[i], b[i]); i+=1;}\n        return iseq;\n    } else if (a.constructor === Object && b.constructor === Object) {\n        var akeys = Object.keys(a), bkeys = Object.keys(b);\n        akeys.sort(); bkeys.sort();\n        var i=0, k, iseq = equals(akeys, bkeys);\n        while (iseq && i < akeys.length) {k=akeys[i]; iseq = equals(a[k], b[k]); i+=1;}\n        return iseq;\n    } return a == b;\n};\nvar _pyfunc_instantiate = function (ob, args) { // nargs: 2\n    if ((typeof ob === \"undefined\") ||\n            (typeof window !== \"undefined\" && window === ob) ||\n            (typeof global !== \"undefined\" && global === ob))\n            {throw \"Class constructor is called as a function.\";}\n    for (var name in ob) {\n        if (Object[name] === undefined &&\n            typeof ob[name] === 'function' && !ob[name].nobind) {\n            ob[name] = ob[name].bind(ob);\n        }\n    }\n    if (ob.__init__) {\n        ob.__init__.apply(ob, args);\n    }\n};\nvar _pyfunc_mult = function (a, b) { // nargs: 2\n    if ((typeof a === 'number') + (typeof b === 'number') === 1) {\n        if (a.constructor === String) return _pymeth_repeat.call(a, b);\n        if (b.constructor === String) return _pymeth_repeat.call(b, a);\n        if (Array.isArray(b)) {var t=a; a=b; b=t;}\n        if (Array.isArray(a)) {\n            var res = []; for (var i=0; i<b; i++) res = res.concat(a);\n            return res;\n        }\n    } return a * b;\n};\nvar _pyfunc_range = function (start, end, step) {\nvar i, res = [];\n    var val = start;\n    var n = (end - start) / step;\n    for (i=0; i<n; i++) {\n        res.push(val);\n        val += step;\n    }\n    return res;\n};\nvar _pyfunc_truthy = function (v) {\n    if (v === null || typeof v !== \"object\") {return v;}\n    else if (v.length !== undefined) {return v.length ? v : false;}\n    else if (v.byteLength !== undefined) {return v.byteLength ? v : false;}\n    else if (v.constructor !== Object) {return true;}\n    else {return Object.getOwnPropertyNames(v).length ? v : false;}\n};\nvar _pymeth_append = function (x) { // nargs: 1\n    if (!Array.isArray(this)) return this.append.apply(this, arguments);\n    this.push(x);\n};\nvar _pymeth_get = function (key, d) { // nargs: 1 2\n    if (this.constructor !== Object) return this.get.apply(this, arguments);\n    if (this[key] !== undefined) {return this[key];}\n    else if (d !== undefined) {return d;}\n    else {return null;}\n};\nvar _pymeth_keys = function () { // nargs: 0\n    if (typeof this['keys'] === 'function') return this.keys.apply(this, arguments);\n    return Object.keys(this);\n};\nvar _pymeth_lstrip = function (chars) { // nargs: 0 1\n    if (this.constructor !== String) return this.lstrip.apply(this, arguments);\n    chars = (chars === undefined) ? ' \\t\\r\\n' : chars;\n    for (var i=0; i<this.length; i++) {\n        if (chars.indexOf(this[i]) < 0) return this.slice(i);\n    } return '';\n};\nvar _pymeth_remove = function (x) { // nargs: 1\n    if (!Array.isArray(this)) return this.remove.apply(this, arguments);\n    for (var i=0; i<this.length; i++) {\n        if (_pyfunc_equals(this[i], x)) {this.splice(i, 1); return;}\n    }\n    var e = Error(x); e.name='ValueError'; throw e;\n};\nvar _pymeth_repeat = function(count) { // nargs: 0\n    if (this.repeat) return this.repeat(count);\n    if (count < 1) return '';\n    var result = '', pattern = this.valueOf();\n    while (count > 1) {\n        if (count & 1) result += pattern;\n        count >>= 1, pattern += pattern;\n    }\n    return result + pattern;\n};\nvar _pymeth_startswith = function (x) { // nargs: 1\n    if (this.constructor !== String) return this.startswith.apply(this, arguments);\n    return this.indexOf(x) == 0;\n};\nvar Buffer, GlooObject, IndexBuffer, Program, Texture2D, Texture3DLike, VertexBuffer, __version__, check_error, console;\n// PyScript module for gloo2.js - lightweight object oriented GL.\n\n{ /* if this_is_js() */\nconsole = window.console;\n}\n__version__ = \"0.3\";\ncheck_error = function (gl, when) {\n    var e, err, err_3, errors, msg, stub1_seq, stub2_itr;\n    when = (when === undefined) ? \"periodic check\": when;\n    // Check this from time to time to detect GL errors.\n    //\n    //     Parameters\n    //     ----------\n    //     when : str\n    //         Shown in the exception to help the developer determine when\n    //         this check was done.\n    errors = [];\n    while (true) {\n        err = gl.getError();\n        if ((_pyfunc_equals(err, gl.NO_ERROR) || (_pyfunc_truthy(errors) && _pyfunc_equals(err, errors[errors.length -1])))) {\n            break;\n        }\n        _pymeth_append.call(errors, err);\n    }\n    if (errors.length) {\n        msg = \"\";\n        stub1_seq = errors;\n        if ((typeof stub1_seq === \"object\") && (!Array.isArray(stub1_seq))) {\n            stub1_seq = Object.keys(stub1_seq);\n        }\n        for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {\n            e = stub1_seq[stub2_itr];\n            msg=_pyfunc_add(msg, e)\n        }\n        err_3 = new Error('RuntimeError:' + (\"OpenGL got errors (\" + when + \"): \" + msg + \"\")); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    return null;\n};\n\nGlooObject = function () {\n    // Abstract base class for all Gloo classes.\n    _pyfunc_instantiate(this, arguments);\n}\nGlooObject.prototype._base_class = Object;\nGlooObject.prototype._class_name = \"GlooObject\";\n\nGlooObject.prototype.__init__ = function (gl) {\n    // Init by passing the webgl context object.\n    this._gl = gl;\n    this.handle = null;\n    this._create();\n    if (!(this.handle !== null)) {throw \"AssertionError: \" + \"this.handle !== null\";}\n    return null;\n};\n\nGlooObject.prototype._create = function () {\n    var err_2;\n    err_2 = new Error('NotImplementedError:' + \"\"); err_2.name = \"NotImplementedError\"; throw err_2;\n    return null;\n};\n\n\nProgram = function () {\n    // The program is the central component to connect gloo objects and shaders.\n    _pyfunc_instantiate(this, arguments);\n}\nProgram.prototype = Object.create(GlooObject.prototype);\nProgram.prototype._base_class = GlooObject.prototype;\nProgram.prototype._class_name = \"Program\";\n\nProgram.prototype.UTYPEMAP = {\"float\": \"uniform1fv\", \"vec2\": \"uniform2fv\", \"vec3\": \"uniform3fv\", \"vec4\": \"uniform4fv\", \"int\": \"uniform1iv\", \"ivec2\": \"uniform2iv\", \"ivec3\": \"uniform3iv\", \"ivec4\": \"uniform4iv\", \"bool\": \"uniform1iv\", \"bvec2\": \"uniform2iv\", \"bvec3\": \"uniform3iv\", \"bvec4\": \"uniform4iv\", \"mat2\": \"uniformMatrix2fv\", \"mat3\": \"uniformMatrix3fv\", \"mat4\": \"uniformMatrix4fv\", \"sampler1D\": \"uniform1i\", \"sampler2D\": \"uniform1i\", \"sampler3D\": \"uniform1i\"};\nProgram.prototype.ATYPEMAP = {\"float\": \"vertexAttrib1f\", \"vec2\": \"vertexAttrib2f\", \"vec3\": \"vertexAttrib3f\", \"vec4\": \"vertexAttrib4f\"};\nProgram.prototype.ATYPEINFO = {\"float\": [1, 5126], \"vec2\": [2, 5126], \"vec3\": [3, 5126], \"vec4\": [4, 5126]};\nProgram.prototype._create = function () {\n    this.handle = this._gl.createProgram();\n    this.locations = {};\n    this._unset_variables = [];\n    this._validated = false;\n    this._samplers = {};\n    this._attributes = {};\n    this._known_invalid = [];\n    return null;\n};\n\nProgram.prototype.delete = function () {\n    // Delete the program.\n    this._gl.deleteProgram(this.handle);\n    return null;\n};\n\nProgram.prototype.activate = function () {\n    // Activate the program.\n    this._gl.useProgram(this.handle);\n    return null;\n};\n\nProgram.prototype.deactivate = function () {\n    // Disable the program.\n    this._gl.useProgram(0);\n    return null;\n};\n\nProgram.prototype.set_shaders = function (vert, frag) {\n    var code, err_3, err_4, errors, frag_handle, gl, handle, i, status, stub3_, tmp, type_, vert_handle;\n    // Set GLSL code for the vertex and fragment shader.\n    //\n    // This function takes care of setting the shading code and\n    // compiling+linking it into a working program object that is ready\n    // to use.\n    //\n    // Parameters\n    // ----------\n    // vert : str\n    //     GLSL code for the vertex shader.\n    // frag : str\n    //     GLSL code for the fragment shader.\n    gl = this._gl;\n    this._linked = false;\n    vert_handle = gl.createShader(gl.VERTEX_SHADER);\n    frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\n    tmp = [[vert, vert_handle, \"vertex\"], [frag, frag_handle, \"fragment\"]];\n    for (i = 0; i < 2; i += 1) {\n        stub3_ = tmp[i];\n        code = stub3_[0];handle = stub3_[1];type_ = stub3_[2];\n        gl.shaderSource(handle, code);\n        gl.compileShader(handle);\n        status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\n        if ((!_pyfunc_truthy(status))) {\n            errors = gl.getShaderInfoLog(handle);\n            err_4 = new Error('RuntimeError:' + (_pyfunc_add(((\"errors in \" + type_) + \" shader:\\n\"), errors))); err_4.name = \"RuntimeError\"; throw err_4;\n        }\n    }\n    gl.attachShader(this.handle, vert_handle);\n    gl.attachShader(this.handle, frag_handle);\n    gl.linkProgram(this.handle);\n    if ((!_pyfunc_truthy(gl.getProgramParameter(this.handle, gl.LINK_STATUS)))) {\n        err_3 = new Error('RuntimeError:' + (\"Program link error:\\n\" + gl.getProgramInfoLog(this.handle))); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    this._unset_variables = this._get_active_attributes_and_uniforms();\n    gl.detachShader(this.handle, vert_handle);\n    gl.detachShader(this.handle, frag_handle);\n    gl.deleteShader(vert_handle);\n    gl.deleteShader(frag_handle);\n    this._known_invalid = [];\n    this._linked = true;\n    return null;\n};\n\nProgram.prototype._get_active_attributes_and_uniforms = function () {\n    var attributes, ca, container, count, cu, getActive, getLocation, gl, i, info, j, m, name, regex, stub4_, stub5_seq, stub6_itr, uniforms, x;\n    // Retrieve active attributes and uniforms to be able to check that\n    // all uniforms/attributes are set by the user.\n    gl = this._gl;\n    this.locations = {};\n    regex = new window.RegExp(\"(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*\");\n    cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n    ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n    attributes = [];\n    uniforms = [];\n    stub5_seq = [[attributes, ca, gl.getActiveAttrib, gl.getAttribLocation], [uniforms, cu, gl.getActiveUniform, gl.getUniformLocation]];\n    if ((typeof stub5_seq === \"object\") && (!Array.isArray(stub5_seq))) {\n        stub5_seq = Object.keys(stub5_seq);\n    }\n    for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {\n        x = stub5_seq[stub6_itr];\n        stub4_ = x;\n        container = stub4_[0];count = stub4_[1];getActive = stub4_[2];getLocation = stub4_[3];\n        for (i = 0; i < count; i += 1) {\n            info = getActive.call(gl, this.handle, i);\n            name = info.name;\n            m = name.match(regex);\n            if (_pyfunc_truthy(m)) {\n                name = m[1];\n                for (j = 0; j < info.size; j += 1) {\n                    _pymeth_append.call(container, ([\"\" + name + \"[\" + j + \"]\", info.type]));\n                }\n            } else {\n                _pymeth_append.call(container, [name, info.type]);\n            }\n            this.locations[name] = getLocation.call(gl, this.handle, name);\n        }\n    }\n    return _pyfunc_add(((function list_comprehenson () {var res = [];var v, iter0, i0;iter0 = attributes;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {v = iter0[i0];{res.push(v[0]);}}return res;}).apply(this)), ((function list_comprehenson () {var res = [];var v, iter0, i0;iter0 = uniforms;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {v = iter0[i0];{res.push(v[0]);}}return res;}).apply(this)));\n};\n\nProgram.prototype.set_texture = function (name, value) {\n    var err_3, handle, unit;\n    // Set a texture sampler.\n    //\n    // A texture is a 2 dimensional grid of colors/intensities that\n    // can be applied to a face (or used for other means by providing\n    // a regular grid of data).\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the texture is known in the GLSL code.\n    // value : Texture2D\n    //     The gloo Texture2D object to bind.\n    if ((!_pyfunc_truthy(this._linked))) {\n        err_3 = new Error('RuntimeError:' + \"Cannot set uniform when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    handle = _pymeth_get.call(this.locations, name, (-1));\n    if (_pyfunc_truthy(handle < 0)) {\n        if ((!_pyfunc_contains(name, this._known_invalid))) {\n            _pymeth_append.call(this._known_invalid, name);\n            console.log(\"Variable \" + name + \" is not an active texture\");\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    this.activate();\n    if (true) {\n        unit = _pymeth_keys.call(this._samplers).length;\n        if (_pyfunc_contains(name, this._samplers)) {\n            unit = this._samplers[name][this._samplers[name].length -1];\n        }\n        this._samplers[name] = [value._target, value.handle, unit];\n        this._gl.uniform1i(handle, unit);\n    }\n    return null;\n};\n\nProgram.prototype.set_uniform = function (name, type_, value) {\n    var a_type, count, err_3, funcname, handle, j, name_;\n    // Set a uniform value.\n    //\n    // A uniform is a value that is global to both the vertex and\n    // fragment shader.\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the uniform is known in the GLSL code.\n    // type_ : str\n    //     The type of the uniform, e.g. 'float', 'vec2', etc.\n    // value : list of scalars\n    //     The value for the uniform. Should be a list even for type float.\n    if ((!_pyfunc_truthy(this._linked))) {\n        err_3 = new Error('RuntimeError:' + \"Cannot set uniform when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    handle = _pymeth_get.call(this.locations, name, (-1));\n    if (_pyfunc_truthy(handle < 0)) {\n        if ((!_pyfunc_contains(name, this._known_invalid))) {\n            _pymeth_append.call(this._known_invalid, name);\n            console.log(\"Variable \" + name + \" is not an active uniform\");\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    count = 1;\n    if ((!_pymeth_startswith.call(type_, \"mat\"))) {\n        a_type = _pymeth_get.call({\"int\": \"float\", \"bool\": \"float\"}, type_, _pymeth_lstrip.call(type_, \"ib\"));\n        count = Math.floor(value.length/(this.ATYPEINFO[a_type][0]));\n    }\n    if (_pyfunc_truthy(count > 1)) {\n        for (j = 0; j < count; j += 1) {\n            if ((_pyfunc_contains((\"\" + name + \"[\" + j + \"]\"), this._unset_variables))) {\n                name_ = \"\" + name + \"[\" + j + \"]\";\n                if (_pyfunc_contains(name_, this._unset_variables)) {\n                    _pymeth_remove.call(this._unset_variables, name_);\n                }\n            }\n        }\n    }\n    funcname = this.UTYPEMAP[type_];\n    this.activate();\n    if (_pymeth_startswith.call(type_, \"mat\")) {\n        this._gl[funcname](handle, false, value);\n    } else {\n        this._gl[funcname](handle, value);\n    }\n    return null;\n};\n\nProgram.prototype.set_attribute = function (name, type_, value, stride, offset) {\n    var args, err_3, funcname, gtype, handle, is_vbo, size, stub7_;\n    stride = (stride === undefined) ? 0: stride;\n    offset = (offset === undefined) ? 0: offset;\n    // Set an attribute value.\n    //\n    // An attribute represents per-vertex data and can only be used\n    // in the vertex shader.\n    //\n    // Parameters\n    // ----------\n    // name : str\n    //     The name by which the attribute is known in the GLSL code.\n    // type_ : str\n    //     The type of the attribute, e.g. 'float', 'vec2', etc.\n    // value : VertexBuffer, array\n    //     If value is a VertexBuffer, it is used (with stride and offset)\n    //     for the vertex data. If value is an array, its used to set\n    //     the value of all vertices (similar to a uniform).\n    // stide : int, default 0\n    //     The stride to \"sample\" the vertex data inside the buffer. Unless\n    //     multiple vertex data are packed into a single buffer, this should\n    //     be zero.\n    // offset : int, default 0\n    //     The offset to \"sample\" the vertex data inside the buffer. Unless\n    //     multiple vertex data are packed into a single buffer, or only\n    //     a part of the data must be used, this should probably be zero.\n    if ((!_pyfunc_truthy(this._linked))) {\n        err_3 = new Error('RuntimeError:' + \"Cannot set attribute when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    is_vbo = value instanceof VertexBuffer;\n    handle = _pymeth_get.call(this.locations, name, (-1));\n    if (_pyfunc_truthy(handle < 0)) {\n        if ((!_pyfunc_contains(name, this._known_invalid))) {\n            _pymeth_append.call(this._known_invalid, name);\n            if ((_pyfunc_truthy(is_vbo) && _pyfunc_truthy(offset > 0))) {\n            } else {\n                console.log(\"Variable \" + name + \" is not an active attribute\");\n            }\n        }\n        return null;\n    }\n    if (_pyfunc_contains(name, this._unset_variables)) {\n        _pymeth_remove.call(this._unset_variables, name);\n    }\n    this.activate();\n    if ((!_pyfunc_truthy(is_vbo))) {\n        funcname = this.ATYPEMAP[type_];\n        this._attributes[name] = [0, handle, funcname, value];\n    } else {\n        stub7_ = this.ATYPEINFO[type_];\n        size = stub7_[0];gtype = stub7_[1];\n        funcname = \"vertexAttribPointer\";\n        args = [size, gtype, this._gl.FALSE, stride, offset];\n        this._attributes[name] = [value.handle, handle, funcname, args];\n    }\n    return null;\n};\n\nProgram.prototype._pre_draw = function () {\n    var args, attr_handle, funcname, stub10_, stub11_seq, stub8_, stub9_seq, tex_handle, tex_target, unit, vbo_handle, x;\n    // Prepare for drawing.\n    this.activate();\n    stub9_seq = this._samplers;\n    for (x in stub9_seq) {\n        if (!stub9_seq.hasOwnProperty(x)){ continue; }\n        x = stub9_seq[x];\n        stub8_ = x;\n        tex_target = stub8_[0];tex_handle = stub8_[1];unit = stub8_[2];\n        this._gl.activeTexture(_pyfunc_add(this._gl.TEXTURE0, unit));\n        this._gl.bindTexture(tex_target, tex_handle);\n    }\n    stub11_seq = this._attributes;\n    for (x in stub11_seq) {\n        if (!stub11_seq.hasOwnProperty(x)){ continue; }\n        x = stub11_seq[x];\n        stub10_ = x;\n        vbo_handle = stub10_[0];attr_handle = stub10_[1];funcname = stub10_[2];args = stub10_[3];\n        if (_pyfunc_truthy(vbo_handle)) {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);\n            this._gl.enableVertexAttribArray(attr_handle);\n            this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n        } else {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);\n            this._gl.disableVertexAttribArray(attr_handle);\n            this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n        }\n    }\n    if ((!_pyfunc_truthy(this._validated))) {\n        this._validated = true;\n        this._validate();\n    }\n    return null;\n};\n\nProgram.prototype._validate = function () {\n    var err_3;\n    if (this._unset_variables.length) {\n        console.log(\"Program has unset variables: \" + this._unset_variables + \"\");\n    }\n    this._gl.validateProgram(this.handle);\n    if ((!_pyfunc_truthy(this._gl.getProgramParameter(this.handle, this._gl.VALIDATE_STATUS)))) {\n        console.log(this._gl.getProgramInfoLog(this.handle));\n        err_3 = new Error('RuntimeError:' + \"Program validation error\"); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    return null;\n};\n\nProgram.prototype.draw = function (mode, selection) {\n    var count, err_3, first, gtype, stub12_;\n    // Draw the current visualization defined by the program.\n    //\n    // Parameters\n    // ----------\n    // mode : GL enum\n    //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\n    // selection : 2-element tuple or IndexBuffer\n    //     The selection to draw, specified either as (first, count) or an\n    //     IndexBuffer object.\n    if ((!_pyfunc_truthy(this._linked))) {\n        err_3 = new Error('RuntimeError:' + \"Cannot draw program if code has not been set\"); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    check_error(this._gl, \"before draw\");\n    if (_pyfunc_truthy(selection instanceof IndexBuffer)) {\n        this._pre_draw();\n        selection.activate();\n        count = selection._buffer_size / 2;\n        gtype = this._gl.UNSIGNED_SHORT;\n        this._gl.drawElements(mode, count, gtype, 0);\n        selection.deactivate();\n    } else {\n        stub12_ = selection;\n        first = stub12_[0];count = stub12_[1];\n        if (_pyfunc_truthy(count)) {\n            this._pre_draw();\n            this._gl.drawArrays(mode, first, count);\n        }\n    }\n    check_error(this._gl, \"after draw\");\n    return null;\n};\n\n\nBuffer = function () {\n    // Base buffer class for vertex data or index data.\n    _pyfunc_instantiate(this, arguments);\n}\nBuffer.prototype = Object.create(GlooObject.prototype);\nBuffer.prototype._base_class = GlooObject.prototype;\nBuffer.prototype._class_name = \"Buffer\";\n\nBuffer.prototype._target = null;\nBuffer.prototype._usage = 35048;\nBuffer.prototype._create = function () {\n    this.handle = this._gl.createBuffer();\n    this._buffer_size = 0;\n    return null;\n};\n\nBuffer.prototype.delete = function () {\n    // Delete the buffer.\n    this._gl.deleteBuffer(this.handle);\n    return null;\n};\n\nBuffer.prototype.activate = function () {\n    // Activete the buffer.\n    this._gl.bindBuffer(this._target, this.handle);\n    return null;\n};\n\nBuffer.prototype.deactivate = function () {\n    // Disable the buffer.\n    this._gl.bindBuffer(this._target, null);\n    return null;\n};\n\nBuffer.prototype.set_size = function (nbytes) {\n    // Set the size of the buffer in bytes.\n    //\n    // Parameters\n    // ----------\n    // nbytes : int\n    //     The number of bytes that the buffer needs to hold.\n    if ((!_pyfunc_equals(nbytes, this._buffer_size))) {\n        this.activate();\n        this._gl.bufferData(this._target, nbytes, this._usage);\n        this._buffer_size = nbytes;\n    }\n    return null;\n};\n\nBuffer.prototype.set_data = function (offset, data) {\n    // Set the buffer data.\n    //\n    // Parameters\n    // ----------\n    // offset : int\n    //     The offset in bytes for the new data.\n    // data : typed array\n    //     The data to upload.\n    this.activate();\n    this._gl.bufferSubData(this._target, offset, data);\n    return null;\n};\n\n\nVertexBuffer = function () {\n    // A buffer for vertex data.\n    _pyfunc_instantiate(this, arguments);\n}\nVertexBuffer.prototype = Object.create(Buffer.prototype);\nVertexBuffer.prototype._base_class = Buffer.prototype;\nVertexBuffer.prototype._class_name = \"VertexBuffer\";\n\nVertexBuffer.prototype._target = 34962;\n\nIndexBuffer = function () {\n    // A buffer for index data.\n    _pyfunc_instantiate(this, arguments);\n}\nIndexBuffer.prototype = Object.create(Buffer.prototype);\nIndexBuffer.prototype._base_class = Buffer.prototype;\nIndexBuffer.prototype._class_name = \"IndexBuffer\";\n\nIndexBuffer.prototype._target = 34963;\n\nTexture2D = function () {\n    // A 2 dimensional regular grid.\n    _pyfunc_instantiate(this, arguments);\n}\nTexture2D.prototype = Object.create(GlooObject.prototype);\nTexture2D.prototype._base_class = GlooObject.prototype;\nTexture2D.prototype._class_name = \"Texture2D\";\n\nTexture2D.prototype._target = 3553;\nTexture2D.prototype._types = {\"Int8Array\": 5120, \"Uint8Array\": 5121, \"Int16Array\": 5122, \"Uint16Array\": 5123, \"Int32Array\": 5124, \"Uint32Array\": 5125, \"Float32Array\": 5126};\nTexture2D.prototype._create = function () {\n    this.handle = this._gl.createTexture();\n    this._shape_format = null;\n    return null;\n};\n\nTexture2D.prototype.delete = function () {\n    // Delete the texture.\n    this._gl.deleteTexture(this.handle);\n    return null;\n};\n\nTexture2D.prototype.activate = function () {\n    // Activate the texture.\n    this._gl.bindTexture(this._target, this.handle);\n    return null;\n};\n\nTexture2D.prototype.deactivate = function () {\n    // Disable the texture.\n    this._gl.bindTexture(this._target, 0);\n    return null;\n};\n\nTexture2D.prototype._get_alignment = function (width) {\n    var alignment, alignments, stub13_seq, stub14_itr;\n    // Determines a textures byte alignment. If the width isn't a\n    //         power of 2 we need to adjust the byte alignment of the image.\n    //         The image height is unimportant.\n    //\n    //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n    alignments = [4, 8, 2, 1];\n    stub13_seq = alignments;\n    if ((typeof stub13_seq === \"object\") && (!Array.isArray(stub13_seq))) {\n        stub13_seq = Object.keys(stub13_seq);\n    }\n    for (stub14_itr = 0; stub14_itr < stub13_seq.length; stub14_itr += 1) {\n        alignment = stub13_seq[stub14_itr];\n        if ((_pyfunc_equals((width % alignment), 0))) {\n            return alignment;\n        }\n    }\n    return null;\n};\n\nTexture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {\n    // Set the texture wrapping mode.\n    //\n    // Parameters\n    // ----------\n    // wrap_s : GL enum\n    //     The mode to wrap the x dimension. Valid values are REPEAT\n    //     CLAMP_TO_EDGE MIRRORED_REPEAT\n    // wrap_t : GL enum\n    //     The mode to wrap the y dimension. Same options as for wrap_s.\n    this.activate();\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);\n    return null;\n};\n\nTexture2D.prototype.set_interpolation = function (min, mag) {\n    // Set the texture interpolation mode\n    //\n    // Parameters\n    // ----------\n    // min : GL enum\n    //     The interpolation mode when minifying (i.e. zoomed out). Valid\n    //     values are LINEAR and NEAREST.\n    // max : GL enum\n    //     The interpolation mode when magnifying (i.e. zoomed in). Valid\n    //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\n    //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\n    this.activate();\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);\n    this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);\n    return null;\n};\n\nTexture2D.prototype.set_size = function (shape, format) {\n    var height, stub15_, width;\n    // Set the size of the 2D texture.\n    //\n    // Parameters\n    // ----------\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // format : GL enum\n    //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n    //     RGB, and RGBA.\n    stub15_ = shape;\n    height = stub15_[0];width = stub15_[1];\n    if ((!_pyfunc_equals([height, width, format], this._shape_format))) {\n        this._shape_format = [height, width, format];\n        this.activate();\n        this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);\n    }\n    this.u_shape = [height, width];\n    return null;\n};\n\nTexture2D.prototype.set_data = function (offset, shape, data) {\n    var _, alignment, err_3, format, gtype, height, stub16_, stub17_, width, x, y;\n    // Set the 2D texture data.\n    //\n    // Parameters\n    // ----------\n    // offset : tuple of ints\n    //     Offset in pixels for each dimension.\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // data : typed array\n    //     The actual pixel data. Can be of any type, but on the GPU the\n    //     dat is stored in 8 bit precision.\n    if (_pyfunc_equals(shape.length, 2)) {\n        shape = [shape[0], shape[1], 1];\n    }\n    this.activate();\n    format = this._shape_format[2];\n    stub16_ = shape;\n    height = stub16_[0];width = stub16_[1];_ = stub16_[2];\n    stub17_ = offset;\n    y = stub17_[0];x = stub17_[1];\n    gtype = _pymeth_get.call(this._types, data.constructor.name, null);\n    if ((gtype === null)) {\n        err_3 = new Error('ValueError:' + (\"Type \" + data.constructor.name + \" not allowed for texture\")); err_3.name = \"ValueError\"; throw err_3;\n    }\n    alignment = this._get_alignment(_pyfunc_mult(shape[shape.length -2], shape[shape.length -1]));\n    if ((!_pyfunc_equals(alignment, 4))) {\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);\n    }\n    this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\n    if ((!_pyfunc_equals(alignment, 4))) {\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);\n    }\n    return null;\n};\n\n\nTexture3DLike = function () {\n    // A 2D texture with support to simulate a 3D texture.\n    //\n    // To use this class, use set_size() and set_data() as if it was a 3D\n    // texture. Add the GLSL_SAMPLE_NEAREST or GLSL_SAMPLE_LINEAR to the\n    // shader to add the sample3D() function that can be used instead of\n    // texture2D(). This function needs ``shape`` and ``tiles`` arguments\n    // which can be set via uniforms, using the ``u_shape`` and ``u_tiles``\n    // attributes of this object.\n    _pyfunc_instantiate(this, arguments);\n}\nTexture3DLike.prototype = Object.create(Texture2D.prototype);\nTexture3DLike.prototype._base_class = Texture2D.prototype;\nTexture3DLike.prototype._class_name = \"Texture3DLike\";\n\nTexture3DLike.prototype.GLSL_SAMPLE_NEAREST = \"\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don't let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float zindex = floor(texcoord.z * shape.z);\\n\\n            // Do a lookup in the 2D texture\\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\\n\\n            return texture2D(tex, vec2(u,v));\\n        }\\n    \";\nTexture3DLike.prototype.GLSL_SAMPLE_LINEAR = \"\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don't let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float z = texcoord.z * shape.z;\\n            float zindex1 = floor(z);\\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\\n\\n            float zindex2 = zindex1 + 1.0;\\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\\n\\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\\n\\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\\n        }\\n    \";\nTexture3DLike.prototype._get_tile_info = function (shape) {\n    var err_3, max_size, ncols, nrows;\n    max_size = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n    nrows = Math.floor(max_size/shape[1]);\n    nrows = Math.min(nrows, shape[0]);\n    ncols = window.Math.ceil(shape[0] / nrows);\n    if (_pyfunc_truthy(_pyfunc_mult(ncols, shape[2]) > max_size)) {\n        err_3 = new Error('RuntimeError:' + (\"Cannot fit 3D data with shape \" + shape + \" onto simulated 2D texture.\")); err_3.name = \"RuntimeError\"; throw err_3;\n    }\n    return [nrows, ncols];\n};\n\nTexture3DLike.prototype.set_size = function (shape, format) {\n    var ncols, nrows, sim_shape, stub18_;\n    // Set the size of the 3D texture.\n    //\n    // Parameters\n    // ----------\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // format : GL enum\n    //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n    //     RGB, and RGBA.\n    stub18_ = this._get_tile_info(shape);\n    nrows = stub18_[0];ncols = stub18_[1];\n    sim_shape = [_pyfunc_mult(shape[1], nrows), _pyfunc_mult(shape[2], ncols)];\n    Texture3DLike.prototype._base_class.set_size.call(this, sim_shape, format);\n    this.u_shape = [shape[0], shape[1], shape[2]];\n    this.u_tiles = [ncols, nrows];\n    return null;\n};\n\nTexture3DLike.prototype.set_data = function (offset, shape, data) {\n    var Type, col, elements_per_tile, err_3, ncols, nrows, row, sim_shape, stub19_, stub20_, tile, z, zeros;\n    // Set the 3D texture data.\n    //\n    // Parameters\n    // ----------\n    // offset : tuple of ints\n    //     Offset in pixels for each dimension.\n    // shape : tuple of ints\n    //     The shape of the data to upload\n    // data : typed array\n    //     The actual pixel data. Can be of any type, but on the GPU the\n    //     dat is stored in 8 bit precision.\n    if (_pyfunc_equals(shape.length, 3)) {\n        shape = [shape[0], shape[1], shape[2], 1];\n    }\n    if ((!(_pyfunc_all(((function list_comprehenson () {var res = [];var i, iter0, i0;iter0 = offset;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {i = iter0[i0];{res.push(_pyfunc_equals(i, 0));}}return res;}).apply(this)))))) {\n        err_3 = new Error('ValueError:' + \"Texture3DLike does not support nonzero offset (for now)\"); err_3.name = \"ValueError\"; throw err_3;\n    }\n    stub19_ = this._get_tile_info(shape);\n    nrows = stub19_[0];ncols = stub19_[1];\n    sim_shape = [_pyfunc_mult(shape[1], nrows), _pyfunc_mult(shape[2], ncols), shape[3]];\n    if (_pyfunc_equals(ncols, 1)) {\n        Texture3DLike.prototype._base_class.set_data.call(this, [0, 0], sim_shape, data);\n    } else {\n        Type = data.constructor;\n        zeros = new Type(_pyfunc_mult(_pyfunc_mult(sim_shape[0], sim_shape[1]), sim_shape[2]));\n        Texture3DLike.prototype._base_class.set_data.call(this, [0, 0], sim_shape, zeros);\n        for (z = 0; z < shape[0]; z += 1) {\n            stub20_ = [Math.floor(z/ncols), z % ncols];\n            row = stub20_[0];col = stub20_[1];\n            elements_per_tile = Math.floor(data.length/shape[0]);\n            tile = data.slice(_pyfunc_mult(z, elements_per_tile),_pyfunc_mult((z + 1), elements_per_tile));\n            Texture3DLike.prototype._base_class.set_data.call(this, [_pyfunc_mult(row, shape[1]), _pyfunc_mult(col, shape[2])], shape.slice(1), tile);\n        }\n    }\n    return null;\n};\n\nmodule.exports = {\n  \"Buffer\": Buffer,\n  \"GlooObject\": GlooObject,\n  \"IndexBuffer\": IndexBuffer,\n  \"Program\": Program,\n  \"Texture2D\": Texture2D,\n  \"Texture3DLike\": Texture3DLike,\n  \"VertexBuffer\": VertexBuffer,\n  \"check_error\": check_error,\n  \"console\": console\n};\n"],"sourceRoot":""}